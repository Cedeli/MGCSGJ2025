[gd_scene load_steps=2 format=3 uid="uid://cet5s034ajxgn"]

[sub_resource type="CSharpScript" id="CSharpScript_c04nk"]
script/source = "using Godot;
using System.Collections.Generic;

public partial class OrbitalPathVisualizer : MeshInstance3D
{
    [Export] public CelestialBody TargetBody;
    [Export] public int PathPointCount = 500;
    [Export] public float SimulationTimeStep = 0.5f;
    [Export] public float LineWidth = 0.1f;
    [Export] public Color PathColor = Colors.White;
    [Export] public bool AutoUpdate = false;
    [Export] public float AutoUpdateInterval = 5.0f;

    private ImmediateMesh _immediateMesh;
    private StandardMaterial3D _material;
    private float _updateTimer = 0.0f;

    public override void _Ready()
    {
        _immediateMesh = new ImmediateMesh();
        Mesh = _immediateMesh;
        
        _material = new StandardMaterial3D
        {
            ShadingMode = BaseMaterial3D.ShadingModeEnum.Unshaded,
            VertexColorUseAsAlbedo = true,
            Transparency = BaseMaterial3D.TransparencyEnum.Alpha
        };
        
        MaterialOverride = _material;
        
        if (TargetBody != null)
        {
            UpdateOrbitPath();
        }
    }

    public override void _Process(double delta)
    {
        if (!AutoUpdate || TargetBody == null) return;
        
        _updateTimer += (float)delta;
        if (_updateTimer >= AutoUpdateInterval)
        {
            UpdateOrbitPath();
            _updateTimer = 0.0f;
        }
    }

    public void UpdateOrbitPath()
    {
        if (TargetBody == null)
        {
            GD.PrintErr(\"No target celestial body assigned to OrbitalPathVisualizer\");
            return;
        }
        
        _immediateMesh.ClearSurfaces();
        
        // Store the current state to restore later
        var originalPosition = TargetBody.GlobalPosition;
        var originalVelocity = TargetBody.LinearVelocity;
        
        // Create a simulation scene to avoid affecting the actual game
        var simulation = CreateSimulation();
        
        // Draw the path
        _immediateMesh.SurfaceBegin(Mesh.PrimitiveType.LineStrip);
        
        var positions = new List<Vector3>();
        var simulatedBody = simulation[TargetBody.Name] as CelestialBody;
        
        if (simulatedBody != null)
        {
            for (int i = 0; i < PathPointCount; i++)
            {
                positions.Add(simulatedBody.GlobalPosition);
                
                // Step simulation forward
                simulation.Root.PropagateNotification((int)Node.NotificationPhysicsProcess);
                for (int s = 0; s < 5; s++) // Multiple physics steps for stability
                {
                    simulation.Root.PropagateNotification((int)Node.NotificationIntegrateForces);
                }
            }
            
            // Create a smooth line with all points
            foreach (var pos in positions)
            {
                _immediateMesh.SurfaceSetColor(PathColor);
                _immediateMesh.SurfaceAddVertex(ToLocal(pos));
            }
            
            // Close the loop if the orbit is roughly periodic
            if (positions.Count > 2 && 
                positions[0].DistanceTo(positions[positions.Count - 1]) < 
                originalPosition.DistanceTo(positions[positions.Count / 2]) * 0.1f)
            {
                _immediateMesh.SurfaceSetColor(PathColor);
                _immediateMesh.SurfaceAddVertex(ToLocal(positions[0]));
            }
        }
        
        _immediateMesh.SurfaceEnd();
        
        // Clean up simulation
        simulation.Free();
    }

    private SceneTree CreateSimulation()
    {
        // Create a private scene tree for simulation
        var simulationTree = new SceneTree();
        var simulationRoot = new Node3D();
        simulationTree.Root.AddChild(simulationRoot);
        
        // Clone the celestial bodies
        var bodies = GetTree().GetNodesInGroup(\"celestial_bodies\");
        var bodyMap = new Dictionary<string, CelestialBody>();
        
        foreach (var body in bodies)
        {
            if (body is CelestialBody celestialBody)
            {
                var clone = (CelestialBody)celestialBody.Duplicate();
                clone.Position = celestialBody.GlobalPosition;
                clone.LinearVelocity = celestialBody.LinearVelocity;
                clone.Mass = celestialBody.Mass;
                simulationRoot.AddChild(clone);
                bodyMap[celestialBody.Name] = clone;
            }
        }
        
        // Fix the parent references
        foreach (var body in bodies)
        {
            if (body is CelestialBody celestialBody && celestialBody.OrbitParent != null)
            {
                var clone = bodyMap[celestialBody.Name];
                if (bodyMap.ContainsKey(celestialBody.OrbitParent.Name))
                {
                    clone.OrbitParent = bodyMap[celestialBody.OrbitParent.Name];
                }
            }
        }
        
        return simulationTree;
    }
    
    // Add this method to be called from the editor or other scripts
    public void DrawOrbit()
    {
        UpdateOrbitPath();
    }
}"

[node name="OrbitSimulation" type="MeshInstance3D"]
script = SubResource("CSharpScript_c04nk")
